/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/modules/counertanim.js":
/*!***************************************!*\
  !*** ./src/js/modules/counertanim.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startInit": () => (/* binding */ startInit)
/* harmony export */ });


function startInit() {
	const sections = document.querySelectorAll('.section-counter')
	// проверка на наличие data аттрибута и запуск для каждого блока
	function counterInit(counterItems) {
		const digitCounters = counterItems ? counterItems : document.querySelectorAll('[data-counter]');
		if (digitCounters) {
			digitCounters.forEach(digitCounter => {
				digitCounterAnimate(digitCounter)
			});
		}
	}

	// анимация
	function digitCounterAnimate(digitCounter) {
		let startTimeStamp = null;
		// можно задать или по умолчанию
		const duration = parseInt(digitCounter.dataset.counter) ? parseInt(digitCounter.dataset.counter) : 1000;
		// начальные заданные данные
		const checkValue = digitCounter.dataset.value;
		const objValueDot = {};
		const objValueCom = {};
		if (checkValue.includes(',')) {
			objValueCom.zero = checkValue.split(',')[0];
			objValueCom.first = checkValue.split(',')[1];
			objValueCom.second = checkValue.split(',')[2];

		} else if (checkValue.includes('.')) {
			objValueDot.zero = checkValue.split('.')[0];
			objValueDot.first = checkValue.split('.')[1];
			objValueDot.second = checkValue.split('.')[2];
		}
		else {
			objValueDot[0] = parseInt(digitCounter.innerHTML);
		}
		if (Object.keys(objValueDot).length !== 0 && objValueDot.constructor === Object || Object.keys(objValueCom).length !== 0 && objValueCom.constructor === Object) {
			const step = (time) => {
				// присваиваем время начал
				if (!startTimeStamp) startTimeStamp = time;
				// прогресс прошедшее время-время начала/1000, округлить к меньшему 
				const progress = Math.min((time - startTimeStamp) / duration, 1);
				if (digitCounter.dataset.value.includes('.')) {
					digitCounter.innerHTML = `${Math.floor(progress * objValueDot.zero)}.${Math.floor(progress * objValueDot.first)}${objValueDot && objValueDot.second || ''}`;
				}
				if (digitCounter.dataset.value.includes(',')) {
					digitCounter.innerHTML = `${Math.floor(progress * objValueCom.zero)},${Math.floor(progress * objValueCom.first)},${Math.floor(progress * objValueCom.second)}`;
				}
				if (progress < 1) {
					window.requestAnimationFrame(step)
				}
			}
			// запускает саму функцию
			window.requestAnimationFrame(step);
		}
	}

	//порог пересечения
	let options = {
		threshold: 0.3,
	}

	let observer = new IntersectionObserver((entries, observer) => {
		entries.forEach(entry => {
			if (entry.isIntersecting) {
				const targetElement = entry.target;
				const digitCounters = targetElement.querySelectorAll('[data-counter]');
				if (digitCounters) {
					counterInit(digitCounters);
				}
				observer.unobserve(entry.target)
			}
		})
	}, options);

	if (sections.length > 0) {

		sections.forEach((section => observer.observe(section)));
	}
} 

/***/ }),

/***/ "./src/js/modules/functions.js":
/*!*************************************!*\
  !*** ./src/js/modules/functions.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "burger": () => (/* binding */ burger),
/* harmony export */   "filter": () => (/* binding */ filter),
/* harmony export */   "ibg": () => (/* binding */ ibg),
/* harmony export */   "isMobile": () => (/* binding */ isMobile),
/* harmony export */   "isWebp": () => (/* binding */ isWebp),
/* harmony export */   "map": () => (/* binding */ map),
/* harmony export */   "ripple": () => (/* binding */ ripple)
/* harmony export */ });
const isMobile = {
	Android: function () { return navigator.userAgent.match(/Android/i); },
	BlackBerry: function () { return navigator.userAgent.match(/BlackBerry/i); },
	iOS: function () { return navigator.userAgent.match(/iPhone|iPad|iPod/i); },
	Opera: function () { return navigator.userAgent.match(/Opera Mini/i); },
	Windows: function () { return navigator.userAgent.match(/IEMobile/i); },
	any: function () { return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows()); }
};

function isWebp() {
	// Проверка поддержки webp
	function testWebP(callback) {
		let webP = new Image();
		webP.src = "https://www.gstatic.com/webp/gallery/1.webp";

		webP.onload = function () {
			callback(webP.height > 0);
		};
		webP.onerror = function () {
			callback(false);
		};
	}
	// Добавление класса _webp или _no-webp для HTML
	testWebP((support) => {
		let className = support === true ? 'webp' : 'no-webp';
		document.documentElement.classList.add(className);
	});
};

function burger() {
	let burgerButton = document.querySelector('.header__burger');
	let burgerMenu = document.querySelector('.header__menu');
	if (burgerButton) {
		burgerButton.addEventListener('click', () => {
			burgerButton.classList.toggle('active')
			burgerMenu.classList.toggle('active');
			document.body.classList.toggle('lock');
		})
	}
};

function ibg() {
	let imgbackround = document.querySelectorAll(".ibg");
	if (imgbackround.length > 0) {
		imgbackround.forEach(imgbg => imgbg.style.backgroundImage = 'url(' + imgbg.querySelector('img').getAttribute('src') + ')');
	}
};
function ripple() {
	document.addEventListener('click', (e) => {
		const target = e.target
		if (target.closest('[data-ripple]')) {
			const button = target.closest('[data-ripple]');
			const ripple = document.createElement('span');
			const diametr = Math.max(button.clientWidth, button.clientHeight);
			const radius = diametr / 2;

			ripple.style.width = ripple.style.height = diametr + 'px';
			ripple.style.left = `${e.pageX - (button.getBoundingClientRect().left + scrollX) - radius}px`;
			ripple.style.top = `${e.pageY - (button.getBoundingClientRect().top + scrollY) - radius}px`;
			ripple.classList.add('btn__ripple');

			//проверка на наличие значяение аттрибута data. Просто не плодит span, а так разницы нет
			button.dataset.ripple === 'once' && button.querySelector('.btn__ripple') ? button.querySelector('.btn__ripple').remove() : null;

			button.append(ripple);

			const timeOut = getAnimationDuration(ripple);

			setTimeout(() => {
				ripple ? ripple.remove() : null
			}, timeOut)

			function getAnimationDuration(ripple) {
				const duration = window.getComputedStyle(ripple).animationDuration
				return duration.includes('ms') ? duration.replace('ms', '') : duration.replace('s', '') * 1000;
			}
		}
	})
};

function filter() {
	const nav = document.querySelector('.upper-block__list');
	const blocksFilter = document.querySelectorAll('.down-block__card');
	nav.addEventListener('click', (e) => {
		if (!e.target.tagName == "LI") return false;
		nav.querySelectorAll('li').forEach(li => { li.classList.remove('active'); })
		blocksFilter.forEach(block => {
			block.classList.remove('hide');
			setTimeout(() => {
				block.style.display = 'grid';
			}, 300);
			const filterTarget = e.target.dataset.f;
			if (!block.classList.contains(filterTarget) && filterTarget !== 'all') {
				block.classList.add('hide');
				setTimeout(() => {
					block.style.display = 'none';
				}, 300);
			}
			e.target.classList.add('active');
		})

	})
}

function map() {
	let myMap = new ymaps.Map("map", {
		center: [51.61826714408352, 9.315691535777491],
		zoom: 3,
	});
	let placeMark = new ymaps.Placemark([51.0937974395966, 10.013996457245618], {}, {
		iconLayout: 'default#image',
		iconImageHref: "~/../img/icons/map.svg",
		iconImageSize: [30, 40],
		iconImageOffset: [-15, -30]
	})
	let placeMark1 = new ymaps.Placemark([63.112602880950064, 15.638996496177715], {}, {
		iconLayout: 'default#image',
		iconImageHref: "~/../img/icons/map.svg",
		iconImageSize: [30, 40],
		iconImageOffset: [-15, -30]
	})
	let placeMark2 = new ymaps.Placemark([59.952757468116125, 10.673176149307977], {}, {
		iconLayout: 'default#image',
		iconImageHref: "~/../img/icons/map.svg",
		iconImageSize: [30, 40],
		iconImageOffset: [-25, -30]
	})
	let placeMark3 = new ymaps.Placemark([41.99698185251685, 12.51887928708257], {}, {
		iconLayout: 'default#image',
		iconImageHref: "~/../img/icons/map.svg",
		iconImageSize: [30, 40],
		iconImageOffset: [0, -30]
	})
	let placeMark4 = new ymaps.Placemark([40.44352342041553, -3.9166677016721483], {}, {
		iconLayout: 'default#image',
		iconImageHref: "~/../img/icons/map.svg",
		iconImageSize: [30, 40],
		iconImageOffset: [-15, -30]
	})
	myMap.controls.remove('trafficControl');
	myMap.controls.remove('geolocationControl');
	myMap.controls.remove('rulerControl');
	myMap.controls.remove('zoomControl');
	myMap.controls.remove('typeSelector');
	myMap.controls.remove('searchControl');
	if (myMap) {
		myMap.geoObjects.add(placeMark);
		myMap.geoObjects.add(placeMark1);
		myMap.geoObjects.add(placeMark2);
		myMap.geoObjects.add(placeMark3);
		myMap.geoObjects.add(placeMark4);
	}
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/functions.js */ "./src/js/modules/functions.js");
/* harmony import */ var _modules_counertanim_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/counertanim.js */ "./src/js/modules/counertanim.js");


;


document.addEventListener('DOMContentLoaded', (e) => {
	_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.isWebp();
	_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.burger();
	_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.ibg();
	_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.ripple();
	_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.filter();
	ymaps.ready(_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.map);
})

window.addEventListener('load', () => {
	;(0,_modules_counertanim_js__WEBPACK_IMPORTED_MODULE_1__.startInit)();
});

})();

/******/ })()
;
//# sourceMappingURL=app.min.js.map